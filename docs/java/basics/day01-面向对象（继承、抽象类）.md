## day01面向对象【继承、抽象类】

## 今日学习内容-2020.9.16

- 继承
- 方法重写
- this/super关键字
- 抽象类

## 一、类与对象

### 1.1 什么是类

类是现实事物的抽象，将现实事物描述成对应的类，其行为封装为方法，属性封装为成员变量。

### 1.2 什么是对象

对象是从类中得到的具体实例！在定义Person类并没有一个具体的人出现，而创建对象后，就会出现一个具体的人

## 二、继承

### 2.1 说出继承的概念

当要定义一个类(讲师)时，发现已有类(员工)和要定义的类相似，并且要定义的类属于已有类的一种时，可以将要定义类定义为已有类的子类。同时也可以反过来思考，当多个类(讲师，助教，班主任)有共性内容，可以将共性内容向上抽取，抽取到一个新的类(员工)中,那么多个类和新的类形成的关系叫做继承。

### 2.2 写出继承的格式

通过 `extends` 关键字，可以声明一个子类继承另外一个父类，定义格式如下：

```java
class 父类 {
	...
}
class 子类 extends 父类 {
	...
}
```

### 2.3 区分this和super的作用

**super和this的含义**

- **super** ：代表父类的**存储空间标识**(可以理解为父亲的引用)。

- **this** ：代表**当前对象的引用**(谁调用就代表谁)。

**super和this的用法**

1. 访问成员

```java
this.成员变量    	--    本类的
super.成员变量    	--    父类的

this.成员方法名()  	--    本类的    
super.成员方法名()   --    父类的

```

用法演示，代码如下：

```java
class Animal {
    public void eat() {
        System.out.println("animal : eat");
    }
}
 
class Cat extends Animal {
    public void eat() {
        System.out.println("cat : eat");
    }
    public void eatTest() {
        this.eat();   // this  调用本类的方法
        super.eat();  // super 调用父类的方法
    }
}
 
public class ExtendsDemo08 {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.eat();
        Cat c = new Cat();
        c.eatTest();
    }
}

输出结果为：
animal : eat
cat : eat
animal : eat
```

2. 访问构造方法

```java
this(...)    	--    本类的构造方法
super(...)   	--    父类的构造方法
```

> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。
>
> super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。

## 三、抽象类

### 3.1 写出抽象方法的格式

**抽象方法**

使用`abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。

定义格式：

```java
修饰符 abstract 返回值类型 方法名 (参数列表)；
```

代码举例：

```java
public abstract void run()；
```

### 3.2 写出抽象类的格式

**抽象类**

如果一个类包含抽象方法，那么该类必须是抽象类。

定义格式：

```java
public abstract class 类名字 { 
  
}
```

代码举例：

```java
public abstract class Employee {
    public abstract void work()；
}
```

### 3.3 注意事项

关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。

1. 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。

   > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

   > 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。

3. 抽象类中，可以有成员变量。

   > 理解：子类的共性的成员变量 , 可以定义在抽象父类中。

4. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

   > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

5. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 

   > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

